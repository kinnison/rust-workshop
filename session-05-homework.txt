Session 5 homework
==================

As with session 4, this session's homework is entirely focussed on your `bft`
project.  Like in session 4, a lot of the detail will be left up to you.  At
the end of this session's homework, your `bft` tool will be closer to
interpreting the hello-world program which we have been carrying around since
session 1.

This is a large amount of work and you are not expected to necessarily complete
it within an hour.

Task One - Shaking your head
============================

It's time - We're going to make our basic VM in `bft_interp` into a BF
interpreter.  To do this we're going to need to extend our struct slightly.

Firstly, you're going to want to add a member to the struct to represent the
head location on the tape.  This should default to the first tape location
(zero).

This member will need some careful handling, at this point our interpreter
could hit a runtime error (e.g. the head falling off either end of the tape).

Add an enumeration to your `bft_interp` crate which will be the errors returned
by the VM.  I suggest that the first variant should be for the head being moved
to an invalid position (before zero, or after the last cell in a non
auto-extending case).  It'd be helpful if the variant were constructed with the
marked instruction which caused the problem, so we can report the error nicely.

To make this possible to do, we're going to want to know the "program counter"
for the VM, so add this to your struct as well, and notice that we'll need the
program borrow in the struct as well.  Alter the `new` method to also take
a borrow of a program, adjust your tests appropriately, and also the `main`
function in `bft`.

Now you can add a "Move Head Left" and "Move Head Right" pair of methods to
your struct's impl block which do the requisite work on the head position
member (so they need to take `&mut self`) and return something like a
`Result<(), VMError>`

Remember to add documentation and tests for these functions, testing both the
success and the failure situations.

Task Two - Traits and maths
===========================

Following the same pattern as for the move-left and move-right methods, add
methods for incrementing and decrementing the values in the cells.  Since we're
modelling a system where values wrap between 0 and the maximum unsigned integer
for the type in question, you're going to want to use `wrapped_add` and
`wrapped_sub` which might lead you to need to write a trait to provide wrapping
increment and decrement, write an impl for u8 for that, and then add some more
type constraints to the VM impl in order to make them available.

Remember to write some tests, docs, etc, so that it's nice and clear what's
going on.

Task Three - Basic I/O
======================

Now we want to add I/O.  We want to do this moderately generically in order
that we can test these functions usefully.  As such, ensure that the function
for reading into a cell takes any type which implements the Read trait and
reads a single byte from that reader.  Note that since this will introduce IO
errors into your system, you should add a variant to your `VMError` enumeration
for IO errors.  It should take the IO error *and* the marked instruction.

While you can wrapper up the IO error manually, it'd be nice to enable the
use of the `?` operator on the `.read()` call by adding a From impl to convert
from a `std::io::Error` to your `VMError` type.  Sadly this isn't easily done
and so for this part of your homework, do a manual wrapper and add a comment in
one or other of the input or output routines explaining why you can't use `?`
to do this.

Your output function should take any Write impl, and do similarly.

Remember that your functions need documentation and also tests.  You can use
the `std::io::Cursor<Vec<u8>>` type to provide readers and writers for the
purpose of testing your input and output functions.

END OF SESSION FIVE

-------------------------------------------------------------------------------

Session 6 homework
==================

As with session 5, this session's homework is entirely focussed on your `bft`
project.  Like in session 5, a lot of the detail will be left up to you.  At
the end of this session's homework, your `bft` tool will finally be able to be
interpreting the hello-world program which we have been carrying around since
session 1.

This is a large amount of work and you are not expected to necessarily complete
it within an hour.

Task One - Looping constructs
=============================

The looping constructs are the hardest bit for our interpreter to implement.
Both do a test and optional jump.

From Wikipedia, rephrased slightly:

`[`: if the cell at the head is zero, then, instead of moving the instruction
     pointer forward to the next command, jump it forward to the command after
     the matching `]` command.
`]`: if the cell at the head is nonzero, then instead of moving the
     instruction pointer forward to the next command, jump it back to the
     command after the matching `[` command.

We can simplify this by picking one or other of the brackets and implementing
the other as an unconditional jump to the matching bracket to allow the test
to be implemented at that bracket.

In order to do this, we clearly need to refine our programming pattern for the
instruction implementations.  Let's change `Result<(), VMError>` into
`Result<usize, VMError>` to return the *next* instruction pointer to use.  For
all the instructions we've already implemented, this will simply be the current
instruction pointer (program counter) plus one.

Once you've made the above changes to your VM struct and its documentation and
tests, we can begin the looping construct work.  If you didn't do the extra
credit in task three, now's the time to go back and do so, because it'll really
help you with the _matching_ point above.

Pick one of start-loop or end-loop to implement as the trivial case, implement
it, document it, and write tests for it.

Now, add a function for the other of the two, add the cell check, and return
the appropriate new instruction pointer according to the check's result.
Document and test this function.

Task Two - A first VM loop
==========================

We're finally ready to add our initial VM loop.  We're going to be replacing
our debug printout interpreter from last time.  Our VM loop needs to take a
reader, and a writer, (probably separately) and will run the program until
either an error occurs, or else the program counter goes outside of the program
at which point the program terminates cleanly.  As such, the interpret method
like looks something like:

    pub fn interpret<R, W>(&mut self, input: R, output: W) -> Result<(), VMError>
      where
	R: Read,
	W: Write,

I imagine that the body of this function will consist of either a `loop {}` or
a `while` loop, with a `match` statement across the instruction at the current
program counter, dispatching to the requisite method implemented above,
updating the program counter, propagating errors as appropriate.

Don't forget to document and to test your VM loop as well.  Either by means
of IO, or, for now, by means of running a simple program and then checking the
content of one or more of the cells in the tape.

When you add support to your `main()` to call this interpreter loop, remember
that you will have to report errors nicely to the user, as returned from the
interpreter.

Assuming all has gone well, you ought to be able to, at this point, run `cargo
run -- helloworld.bf` where `helloworld.bf` is the BF program you received in
previous homework.

Task Three - Make it neat
=========================

You may have noticed that the `helloworld.bf` I provided does not terminate
its output with a nice newline.  It would be super nice if you could detect
that and output a newline (perhaps in `main()` perhaps in `VM::interpret()`)
should this happen, just so that output is neater.

Don't forget to document it and test it.

